===
Context assign
===
fn context_assign() -> () {
    ctx.type = ABC;
}

---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type)
        (block
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (identifier))))))

===
Assign expression from function call
===

fn assign_from_fn_call() -> () {
    ctx.type = get_type();
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type)
        (block
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (function_call_expression
                (identifier)))))))

===
Return function call with one parameter
===
fn return_fn_call_with_param() -> Type {
    return get_type(1);
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (return_statement
            (function_call_expression
              (identifier)
              (number_literal))))))

===
Function call with multiple parameters
===
fn fn_call_with_multiple_params() -> () {
    get_type(1, true, a, get_name("abc"));
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type)
        (block
          (expression_statement
            (function_call_expression
              (identifier)
              (number_literal)
              (bool_literal)
              (identifier)
              (function_call_expression
                (identifier)
                (string_literal)))))))

===
Context constructor with various binary expressions
===
fn constructor() -> some_context {
    ctx.type = ContextType::Program;
    ctx.arh = Arch::WASM;
    ctx.max_curr_mem = 2 ** 16;
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (member_access_expression
                (identifier)
                (expand_operator)
                (identifier))))
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (member_access_expression
                (identifier)
                (expand_operator)
                (identifier))))
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (binary_expression
                (number_literal)
                (pow_operator)
                (number_literal)))))))

===
Create and assign Array<u32> without parameters
===
fn constructor() -> some_context {
    ctx.mem = Array<u32>::new();
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (function_call_expression
                (member_access_expression
                  (generic_name
                    (identifier)
                    (type_argument_list
                      (type)))
                  (expand_operator)
                  (identifier))))))))

===
Create and assign Array<i64> with one parameter
===
fn constructor() -> some_context {
    ctx.mem = Array<i64>::new(10);
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (function_call_expression
                (member_access_expression
                  (generic_name
                    (identifier)
                    (type_argument_list
                      (type)))
                  (expand_operator)
                  (identifier))
                (number_literal)))))))

===
Create and assign Array<u64> with multiple parameters
===
fn constructor() -> some_context {
    ctx.mem = Array<u64>::new(10, a, false, get_name("abc"), "str", Array<i32>::new(10 * 2));
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (expression_statement
            (assign_expression
              (member_access_expression
                (identifier)
                (attribute_access_operator)
                (identifier))
              (assign_operator)
              (function_call_expression
                (member_access_expression
                  (generic_name
                    (identifier)
                    (type_argument_list
                      (type)))
                  (expand_operator)
                  (identifier))
                (number_literal)
                (identifier)
                (bool_literal)
                (function_call_expression
                  (identifier)
                  (string_literal))
                (string_literal)
                (function_call_expression
                  (member_access_expression
                    (generic_name
                      (identifier)
                      (type_argument_list
                        (type)))
                    (expand_operator)
                    (identifier))
                  (binary_expression
                    (number_literal)
                    (mul_operator)
                    (number_literal)))))))))

===
Compound binary expression with parenthesized expression
===

fn valid_Address(a: Address) -> Address {
    assert (a < ctx.max_curr_mem && (a % 4));
    return a;
}

---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (type
              (identifier))))
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (expression_statement
            (assert_expression
              (parenthesized_expression
                (binary_expression
                  (binary_expression
                    (identifier)
                    (less_operator)
                    (member_access_expression
                      (identifier)
                      (attribute_access_operator)
                      (identifier)))
                  (and_operator)
                  (parenthesized_expression
                    (binary_expression
                      (identifier)
                      (mod_operator)
                      (number_literal)))))))
          (return_statement
            (identifier)))))

===
Binary and unary mix
===

fn valid_Address(a: Address) -> Address {
    assert (a < ctx.max_curr_mem && !(a % 4) && !a);
    return a;
}

---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (type
              (identifier))))
        (rightarrow_operator)
        (type
          (identifier))
        (block
          (expression_statement
            (assert_expression
              (parenthesized_expression
                (binary_expression
                  (binary_expression
                    (binary_expression
                      (identifier)
                      (less_operator)
                      (member_access_expression
                        (identifier)
                        (attribute_access_operator)
                        (identifier)))
                    (and_operator)
                    (prefix_unary_expression
                      (parenthesized_expression
                        (binary_expression
                          (identifier)
                          (mod_operator)
                          (number_literal)))))
                  (and_operator)
                  (prefix_unary_expression
                    (identifier))))))
          (return_statement
            (identifier)))))
