===
`spec` assign
===
fn spec_assign() -> () {
    self.type = ABC;
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (type_unit)
        (block
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (identifier)))))

===
Assign expression from function call
===
fn assign_from_fn_call() -> () {
    self.type = get_type();
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (type_unit)
        (block
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (function_call_expression
              (identifier))))))

===
Return function call with one parameter
===
fn return_fn_call_with_param() -> Type {
    return get_type(1);
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (identifier)
        (block
          (return_statement
            (function_call_expression
              (identifier)
              (number_literal))))))

===
Function call with multiple parameters
===
fn fn_call_with_multiple_params() -> () {
    get_type(1, true, a, get_name("abc"));
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (type_unit)
        (block
          (expression_statement
            (function_call_expression
              (identifier)
              (number_literal)
              (bool_literal)
              (identifier)
              (function_call_expression
                (identifier)
                (string_literal)))))))

===
`spec` constructor with various binary expressions
===
fn constructor() -> some_spec {
    self.type = specType::Program;
    self.arh = Arch::WASM;
    self.max_curr_mem = 2 ** 16;
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (identifier)
        (block
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (type_member_access_expression
              (identifier)
              (identifier)))
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (type_member_access_expression
              (identifier)
              (identifier)))
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (binary_expression
              (number_literal)
              (number_literal))))))

===
Create and assign Array<u32> without parameters
===
fn constructor() -> some_spec {
    self.mem = Array u32'::new();
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (identifier)
        (block
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (function_call_expression
              (type_member_access_expression
                (generic_name
                  (identifier)
                  (type_argument_list
                    (type_u32)))
                (identifier)))))))

===
Create and assign Array<i64> with one parameter
===
fn constructor() -> some_spec {
    self.mem = Array i64'::new(10);
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (identifier)
        (block
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (function_call_expression
              (type_member_access_expression
                (generic_name
                  (identifier)
                  (type_argument_list
                    (type_i64)))
                (identifier))
              (number_literal))))))

===
Create and assign Array<u64> with multiple parameters
===
fn constructor() -> some_spec {
    self.mem = (Array u64')::new(10, a, false, get_name("abc"), "str", (Array i32')::new(10 * 2));
}
---
    (source_file
      (function_definition
        (identifier)
        (argument_list)
        (identifier)
        (block
          (assign_statement
            (member_access_expression
              (identifier)
              (identifier))
            (function_call_expression
              (type_member_access_expression
                (generic_name
                  (identifier)
                  (type_argument_list
                    (type_u64)))
                (identifier))
              (number_literal)
              (identifier)
              (bool_literal)
              (function_call_expression
                (identifier)
                (string_literal))
              (string_literal)
              (function_call_expression
                (type_member_access_expression
                  (generic_name
                    (identifier)
                    (type_argument_list
                      (type_i32)))
                  (identifier))
                (binary_expression
                  (number_literal)
                  (number_literal))))))))

===
Compound binary expression with parenthesized expression
===

fn valid_Address(a: Address) -> Address {
    assert (a < self.max_curr_mem && (a % 4));
    return a;
}

---
    (source_file
      (function_definition
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (identifier)))
        (identifier)
        (block
          (assert_statement
            (parenthesized_expression
              (binary_expression
                (binary_expression
                  (identifier)
                  (member_access_expression
                    (identifier)
                    (identifier)))
                (parenthesized_expression
                  (binary_expression
                    (identifier)
                    (number_literal))))))
          (return_statement
            (identifier)))))

===
Binary and unary mix
===

fn valid_Address(a: Address) -> Address {
    assert (a < self.max_curr_mem && !(a % 4) && !a);
    return a;
}

---
    (source_file
      (function_definition
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (identifier)))
        (identifier)
        (block
          (assert_statement
            (parenthesized_expression
              (binary_expression
                (binary_expression
                  (binary_expression
                    (identifier)
                    (member_access_expression
                      (identifier)
                      (identifier)))
                  (prefix_unary_expression
                    (unary_not)
                    (parenthesized_expression
                      (binary_expression
                        (identifier)
                        (number_literal)))))
                (prefix_unary_expression
                  (unary_not)
                  (identifier)))))
          (return_statement
            (identifier)))))

===
Binary operators with negative number literals
===

fn main() -> i32 {
  return -1 - -2;
}

---
(source_file
  (function_definition
    (identifier)
    (argument_list)
    (type_i32)
    (block
      (return_statement
        (binary_expression
          (number_literal)
          (number_literal))))))

