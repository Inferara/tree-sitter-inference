===
Base function definition
===

fn func() -> i32 {

}

---

(source_file
    (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type_i32)
        (block)))

===
Function definition without return type
===

fn func() {

}

---

(source_file
    (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (block)))

===
Function with one parameter
===

fn func(x: i32) -> i32 {

}

---

(source_file
    (function_definition
    (function_keyword)
    (identifier)
    (argument_list
        (argument_declaration
            (identifier)
            (type_i32)))
    (rightarrow_operator)
    (type_i32)
    (block)))

===
Function with multiple parameters
===
fn func(x: i32, y: i32) -> i32 {

}
---

(source_file
    (function_definition
        (function_keyword)
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (type_i32))
          (argument_declaration
            (identifier)
            (type_i32)))
        (rightarrow_operator)
        (type_i32)
        (block)))

===
Function with return i32
===

fn func() -> i32 {
    return 0;
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type_i32)
        (block
          (return_statement
            (number_literal)))))

===
Function with return bool literal
===

fn func() -> bool {
    return true;
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type_bool)
        (block
          (return_statement
            (bool_literal)))))

===
Function with return identifier
===
fn constructor() -> some_spec {
}
---
(source_file
    (function_definition
    (function_keyword)
    (identifier)
    (argument_list)
    (rightarrow_operator)
    (identifier)
    (block)))

===
Function returns binary expression
===
fn add(a : i32, b : i32) -> i32 {
    return a + b;
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (type_i32))
          (argument_declaration
            (identifier)
            (type_i32)))
        (rightarrow_operator)
        (type_i32)
        (block
          (return_statement
            (binary_expression
              (identifier)
              (add_operator)
              (identifier))))))

===
Function with forall body
===
fn add(a : i32, b : i32) -> i32 forall {
    return a + b;
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (type_i32))
          (argument_declaration
            (identifier)
            (type_i32)))
        (rightarrow_operator)
        (type_i32)
        (forall_block
          (forall_keyword)
          (block
            (return_statement
              (binary_expression
                (identifier)
                (add_operator)
                (identifier)))))))
===
Function with assume block
===
fn procuring_sorted(func: sf) -> () forall {
    assume {
      a = valid_Address();
      b = valid_Address();
      assert(a <= b);
    }
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list
          (argument_declaration
            (identifier)
            (identifier)))
        (rightarrow_operator)
        (type_unit)
        (forall_block
          (forall_keyword)
          (block
            (assume_block
              (block
                (expression_statement
                  (assign_expression
                    (identifier)
                    (assign_operator)
                    (function_call_expression
                      (identifier))))
                (expression_statement
                  (assign_expression
                    (identifier)
                    (assign_operator)
                    (function_call_expression
                      (identifier))))
                (assert_statement
                  (parenthesized_expression
                    (binary_expression
                      (identifier)
                      (less_equal_operator)
                      (identifier))))))))))
===
Function that returns a unit literal
===
fn func() -> () {
    return ();
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type_unit)
        (block
          (return_statement
            (unit_literal)))))

===
Arrays as parameters and return types
===
fn concatInts(xss : [[i64]]) -> [i64] {

}
---
(source_file
  (function_definition
    (function_keyword)
    (identifier)
    (argument_list
      (argument_declaration
        (identifier)
        (type_array
          (type_array
            (type_i64)))))
    (rightarrow_operator)
    (type_array
      (type_i64))
    (block)))
===
Function with unique block
===
fn func() -> () {
    unique {
        let a: i32 = 0;
    }
}
---
    (source_file
      (function_definition
        (function_keyword)
        (identifier)
        (argument_list)
        (rightarrow_operator)
        (type_unit)
        (block
          (unique_block
            (block
              (variable_definition_statement
                (identifier)
                (type_i32)
                (assign_operator)
                (number_literal)))))))
